-- Minesweeper Pro Guide (improved)
-- Based on your uploaded MSGuide.txt (baseline) :contentReference[oaicite:1]{index=1}
-- Colors: blue = safe-to-reveal, red = mine, purple = wrong flag

-- CONFIG
local ORIGIN = Vector3.new(41.5, 56.5, 71.5) -- adjust
local SPACING = 5
local SCAN_INTERVAL = 0.6 -- slightly faster; increase if you get perf issues
local DEBUG = true
_G.MSGuideEnabled = (_G.MSGuideEnabled == nil) and true or _G.MSGuideEnabled

-- SERVICES
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService('Workspace')
local UserInput = game:GetService('UserInputService')

-- safe wait compatibility
local waitFn = task and task.wait or wait

-- PARTS FOLDER (defensive)
local partsFolder = nil
do
    local ok
    ok = pcall(function()
        partsFolder = Workspace:WaitForChild('Flag', 6):WaitForChild('Parts', 6)
    end)
    if not ok or not partsFolder then
        -- fallback: search immediate children for a likely Parts folder
        for _, v in ipairs(Workspace:GetChildren()) do
            if v.Name == 'Flag' then
                partsFolder = v:FindFirstChild('Parts') or partsFolder
            end
        end
    end
    if not partsFolder then
        warn(
            '[MSGuide] Could not find Workspace.Flag.Parts - script may not function until it appears.'
        )
    end
end

-- UTILITIES
local function dprint(...)
    if DEBUG then
        print('[MSGuide]', ...)
    end
end
local function getPlayerGui()
    if LocalPlayer then
        return LocalPlayer:FindFirstChild('PlayerGui')
            or LocalPlayer:WaitForChild('PlayerGui', 6)
    end
    return nil
end

local function readNumberFromPart(part)
    if not part then
        return nil
    end
    local gui = part:FindFirstChildWhichIsA('SurfaceGui', true)
    if not gui then
        for _, d in ipairs(part:GetDescendants()) do
            if d:IsA('SurfaceGui') then
                gui = d
                break
            end
        end
    end
    if not gui then
        return nil
    end
    local txt = gui:FindFirstChildWhichIsA('TextLabel', true)
    if not txt then
        return nil
    end
    local s = txt.Text or txt.ContentText or ''
    s = tostring(s):gsub('%s+', '')
    return tonumber(s)
end

local function isNumberTile(p)
    if not p then
        return false
    end
    return p.BrickColor == BrickColor.new('Daisy orange')
end
-- Detect flags by child objects, not BrickColor
local function hasAnyFlag(part)
    for _, child in ipairs(part:GetChildren()) do
        if string.find(child.Name, 'Flag') then
            return true
        end
    end
    return false
end

local function isFlaggedTile(part)
    return hasAnyFlag(part)
end

local function isUnrevealedTile(p)
    if not p then
        return false
    end
    local bc = p.BrickColor
    return bc == BrickColor.new('Moss') or bc == BrickColor.new('Shamrock')
end

-- GRID BUILD
local gridMap, partToKey = {}, {}
local function coordFromPosition(pos)
    local x = math.floor(((pos.X - ORIGIN.X) / SPACING) + 0.5)
    local z = math.floor(((pos.Z - ORIGIN.Z) / SPACING) + 0.5)
    return x, z
end
local function keyFromXZ(x, z)
    return ('%d|%d'):format(x, z)
end

local function rebuildMap()
    if not partsFolder then
        return
    end
    local newMap, newPartToKey = {}, {}
    for _, child in ipairs(partsFolder:GetChildren()) do
        if child:IsA('BasePart') then
            local x, z = coordFromPosition(child.Position)
            local k = keyFromXZ(x, z)
            newMap[k] = child
            newPartToKey[child] = k
        end
    end
    gridMap = newMap
    partToKey = newPartToKey
    dprint('Rebuilt map with', #partsFolder:GetChildren(), 'parts')
end

-- attach listeners to keep map fresh
if partsFolder then
    partsFolder.ChildAdded:Connect(rebuildMap)
    partsFolder.ChildRemoved:Connect(function(child)
        -- remove highlight if present
        if child and highlights and highlights[child] then
            releaseHighlight(highlights[child])
            highlights[child] = nil
        end
        rebuildMap()
    end)
end

-- HIGHLIGHTS (fixed pooling)
local highlights, pool = {}, {}

local function acquireHighlight()
    local h = table.remove(pool)
    if h and h.Parent == nil then
        -- re-parent to player gui when used
        local pg = getPlayerGui()
        if pg then
            h.Parent = pg
        end
        return h
    end
    -- if nothing reusable, make new
    local nh = Instance.new('Highlight')
    nh.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    nh.FillTransparency = 0.5
    nh.OutlineTransparency = 1
    local pg = getPlayerGui()
    if pg then
        nh.Parent = pg
    end
    return nh
end

function releaseHighlight(h)
    if not h then
        return
    end
    -- keep highlight alive (don't destroy) so it can be reused
    h.Adornee = nil
    -- detach from PlayerGui to hide
    h.Parent = nil
    table.insert(pool, h)
end

local function setHighlight(part, color)
    if not part or not part:IsDescendantOf(Workspace) then
        return
    end
    local h = highlights[part]
    if not h then
        h = acquireHighlight()
        highlights[part] = h
    end
    h.Adornee = part
    h.FillColor = color
    -- ensure visible
    if h.Parent == nil then
        local pg = getPlayerGui()
        if pg then
            h.Parent = pg
        end
    end
end

local function clearAllHighlights()
    for p, h in pairs(highlights) do
        if h then
            releaseHighlight(h)
        end
    end
    highlights = {}
end

-- DEBUG GUI
local gui, infoLabel
local function setupDebugGui()
    if gui then
        pcall(function()
            gui:Destroy()
        end)
    end
    local pg = getPlayerGui()
    if not pg then
        return
    end

    gui = Instance.new('ScreenGui')
    gui.Name = 'MSGuideDebug'
    gui.ResetOnSpawn = false
    gui.Parent = pg

    local frame = Instance.new('Frame')
    frame.Size = UDim2.new(0, 260, 0, 76)
    frame.Position = UDim2.new(0, 8, 0, 8)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    frame.BackgroundTransparency = 0.35
    frame.Parent = gui

    local title = Instance.new('TextLabel')
    title.Size = UDim2.new(1, 0, 0, 18)
    title.Text = 'MS Guide'
    title.TextColor3 = Color3.new(1, 1, 1)
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 14
    title.BackgroundTransparency = 1
    title.Parent = frame

    infoLabel = Instance.new('TextLabel')
    infoLabel.Size = UDim2.new(1, -8, 1, -22)
    infoLabel.Position = UDim2.new(0, 4, 0, 20)
    infoLabel.BackgroundTransparency = 1
    infoLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
    infoLabel.Font = Enum.Font.SourceSans
    infoLabel.TextSize = 13
    infoLabel.TextWrapped = true
    infoLabel.TextYAlignment = Enum.TextYAlignment.Top
    infoLabel.Text = 'Loading...'
    infoLabel.Parent = frame
end
setupDebugGui()

Players.LocalPlayer.CharacterAdded:Connect(function()
    waitFn(1)
    setupDebugGui()
    clearAllHighlights()
    pool = {}
end)

-- === Advanced Minesweeper Solver (ported & optimized) ===
-- Source ideas: grouping + combinatorial reasoning + probabilities (JS solver)
-- Integrated safely for Roblox (time budget, frontier caps, coroutine yields)

local ADV = {
    -- Hard caps to prevent freezes:
    MAX_GROUP_VARS = 18, -- max unknowns per connected group we will brute-force
    MAX_GLOBAL_VARS = 28, -- if total frontier exceeds this, we skip advanced search
    MAX_SOLUTIONS_PER_GROUP = 250000, -- stop enumerating if this many are found
    TIME_BUDGET_MS = 14, -- per scan budget; keep small to avoid hitch (tune)
    YIELD_EVERY = 5000, -- yield every N nodes to stay responsive
    ENABLE_BEST_GUESS = true, -- show a best-guess (yellow) when no certainty
}

-- low-overhead timer
local function nowMs()
    return os.clock() * 1000
end

-- yield helper to prevent frame hitching
local function softYieldIfNeeded(counter, startMs, budgetMs, everyN)
    if counter % everyN == 0 then
        if (nowMs() - startMs) > budgetMs then
            -- time budget exceeded; signal caller to abort
            return true
        end
        task.defer(function() end) -- micro-yield without visible wait
    end
    return false
end

-- Build a map of "unknown" tile -> digits that constrain it; also group unknowns by connectivity through shared digits.
-- Input:
--   numberTiles: { {part=BasePart, number=int, flagged=int, unknown={BasePart...}} ... }  (from your analyze pass)
-- Output:
--   groups: { { vars={BasePart...}, constraints={ {unknown={BasePart...}, need=int} ... } } ... }
--   allUnknownSet: set of all unknowns seen in frontier
local function buildGroups(numberTiles)
    local unknownToDigits = {}
    local allUnknownSet = {}

    for _, t in ipairs(numberTiles) do
        local need = t.number - (t.flagged or 0)
        if need > 0 and #t.unknown > 0 then
            -- register constraints and unknown->digit edges
            for _, u in ipairs(t.unknown) do
                allUnknownSet[u] = true
                local L = unknownToDigits[u]
                if not L then
                    L = {}
                    unknownToDigits[u] = L
                end
                table.insert(L, t)
            end
        end
    end

    -- BFS over unknowns: two unknowns are connected if they share a digit
    local groups = {}
    local visited = {}

    local function neighborsOf(u)
        -- unknown neighbors share at least one digit with u
        local result = {}
        local digits = unknownToDigits[u]
        if digits then
            for _, d in ipairs(digits) do
                for _, v in ipairs(d.unknown) do
                    if v ~= u then
                        result[v] = true
                    end
                end
            end
        end
        return result
    end

    for u, _ in pairs(allUnknownSet) do
        if not visited[u] then
            local queue = { u }
            visited[u] = true
            local comp = { u }
            local qi = 1
            while queue[qi] do
                local cur = queue[qi]
                qi += 1
                local nbrs = neighborsOf(cur)
                for v, _ in pairs(nbrs) do
                    if allUnknownSet[v] and not visited[v] then
                        visited[v] = true
                        table.insert(comp, v)
                        table.insert(queue, v)
                    end
                end
            end

            -- collect constraints (digits touching any var in this comp)
            local digitSeen = {}
            local constraints = {}
            local varsSet = {}
            for _, v in ipairs(comp) do
                varsSet[v] = true
            end

            for _, v in ipairs(comp) do
                local digits = unknownToDigits[v]
                if digits then
                    for _, d in ipairs(digits) do
                        if not digitSeen[d] then
                            digitSeen[d] = true
                            -- constraint unknowns are intersection of comp with this digit's unknown list
                            local list = {}
                            for _, ku in ipairs(d.unknown) do
                                if varsSet[ku] then
                                    table.insert(list, ku)
                                end
                            end
                            local need = d.number - d.flagged
                            if need < 0 then
                                need = 0
                            end
                            if #list > 0 then
                                table.insert(
                                    constraints,
                                    { unknown = list, need = need }
                                )
                            end
                        end
                    end
                end
            end

            -- finalize group
            table.insert(groups, { vars = comp, constraints = constraints })
        end
    end

    return groups, allUnknownSet
end

-- Backtracking with pruning for a single group.
-- Returns:
--   solved=true/false,
--   solutions=#solutions (capped),
--   mineCount[part]=integer across solutions,
--   safeCount[part]=integer across solutions
local function solveGroup(group, startMs, budget)
    local vars = group.vars
    local n = #vars
    if n == 0 then
        return { solved = true, solutions = 0, mineCount = {}, safeCount = {} }
    end
    if n > ADV.MAX_GROUP_VARS then
        -- too big: skip to protect perf
        return { solved = false, tooBig = true }
    end

    -- Build fast constraint model
    local cons = {}
    for _, c in ipairs(group.constraints) do
        -- copy arrays for speed
        local arr = {}
        for i = 1, #c.unknown do
            arr[i] = c.unknown[i]
        end
        table.insert(cons, { unknown = arr, need = c.need })
    end

    local idxOf = {}
    for i = 1, n do
        idxOf[vars[i]] = i
    end

    -- precompute for quick pruning: for each constraint track remaining unknowns count
    local conNeed = {}
    local conRemain = {}
    local conVars = {}
    for ci, c in ipairs(cons) do
        conNeed[ci] = c.need
        conRemain[ci] = #c.unknown
        local flags = {}
        for _, u in ipairs(c.unknown) do
            flags[idxOf[u]] = true
        end
        conVars[ci] = flags
    end

    local assign = table.create(n) -- nil/unassigned, or true (bomb) / false (safe)
    local mineCount = {}
    local safeCount = {}
    for i = 1, n do
        mineCount[vars[i]] = 0
        safeCount[vars[i]] = 0
    end

    local solutions = 0
    local nodes = 0

    -- order variables: most constrained first (degree heuristic)
    local degrees = {}
    for i = 1, n do
        local deg = 0
        for _, c in ipairs(cons) do
            for _, u in ipairs(c.unknown) do
                if u == vars[i] then
                    deg += 1
                    break
                end
            end
        end
        degrees[i] = { i = i, deg = deg }
    end
    table.sort(degrees, function(a, b)
        return a.deg > b.deg
    end)
    local order = {}
    for k = 1, n do
        order[k] = degrees[k].i
    end

    local function pushValue(i, val)
        -- apply val to constraints that contain var i
        for ci = 1, #cons do
            if conVars[ci][i] then
                if val then -- bomb
                    conNeed[ci] = conNeed[ci] - 1
                end
                conRemain[ci] = conRemain[ci] - 1
                -- early prune
                if conNeed[ci] < 0 or conNeed[ci] > conRemain[ci] then
                    return false
                end
            end
        end
        return true
    end

    local function popValue(i, val)
        for ci = 1, #cons do
            if conVars[ci][i] then
                if val then
                    conNeed[ci] = conNeed[ci] + 1
                end
                conRemain[ci] = conRemain[ci] + 1
            end
        end
    end

    local aborted = false

    local function backtrack(k)
        if aborted then
            return
        end
        nodes += 1
        if softYieldIfNeeded(nodes, startMs, budget, ADV.YIELD_EVERY) then
            aborted = true
            return
        end

        if k > n then
            -- verify (paranoia, constraints already pruned)
            for ci = 1, #cons do
                if conNeed[ci] ~= 0 then
                    return
                end
            end
            solutions += 1
            if solutions > ADV.MAX_SOLUTIONS_PER_GROUP then
                aborted = true
                return
            end
            for i = 1, n do
                local v = assign[i]
                if v == true then
                    mineCount[vars[i]] += 1
                else
                    safeCount[vars[i]] += 1
                end
            end
            return
        end

        local i = order[k]
        -- Try bomb = true
        assign[i] = true
        if pushValue(i, true) then
            backtrack(k + 1)
        end
        popValue(i, true)

        -- Try safe = false
        assign[i] = false
        if pushValue(i, false) then
            backtrack(k + 1)
        end
        popValue(i, false)

        assign[i] = nil
    end

    backtrack(1)

    if aborted and solutions == 0 then
        return { solved = false, aborted = true }
    end

    return {
        solved = true,
        solutions = solutions,
        mineCount = mineCount,
        safeCount = safeCount,
    }
end

-- Public API:
-- Input:
--   numberTiles (same structure your analyze() builds)
--   perfBudgetMs (optional override)
-- Output:
--   result.safeSet[part] = true  (certain)
--   result.mineSet[part] = true  (certain)
--   result.bestGuess = { part = BasePart, p = number } or nil  (lowest mine probability)
--   result.stats = { groups=#, vars=#, solvedGroups=#, solutions=sum }
function AdvancedSolve(numberTiles, perfBudgetMs)
    local startMs = nowMs()
    local budget =
        math.min(ADV.TIME_BUDGET_MS, perfBudgetMs or ADV.TIME_BUDGET_MS)

    -- Build groups from current frontier
    local groups, allUnknownSet = buildGroups(numberTiles)

    -- Count global vars
    local totalVars = 0
    for _, g in ipairs(groups) do
        totalVars += #g.vars
    end

    if totalVars == 0 or totalVars > ADV.MAX_GLOBAL_VARS then
        return {
            safeSet = {},
            mineSet = {},
            bestGuess = nil,
            stats = {
                groups = #groups,
                vars = totalVars,
                solvedGroups = 0,
                solutions = 0,
            },
        }
    end

    local safeSet, mineSet = {}, {}
    local bestGuess = nil
    local solvedGroups = 0
    local sumSolutions = 0

    for _, g in ipairs(groups) do
        if (nowMs() - startMs) > budget then
            break
        end
        local solution = solveGroup(g, startMs, budget)
        if solution.solved and solution.solutions > 0 then
            solvedGroups += 1
            sumSolutions += solution.solutions

            -- derive certainties + probabilities per var
            for _, p in ipairs(g.vars) do
                local m = solution.mineCount[p] or 0
                local s = solution.safeCount[p] or 0
                local tot = m + s
                if tot == solution.solutions then
                    if m == tot then
                        mineSet[p] = true
                    elseif s == tot then
                        safeSet[p] = true
                    else
                        -- mixed; compute probability
                        local prob = m / tot
                        if ADV.ENABLE_BEST_GUESS then
                            if not bestGuess or prob < bestGuess.p then
                                bestGuess = { part = p, p = prob }
                            end
                        end
                    end
                else
                    -- under-count due to early abort; skip certainty, still candidate for guessing
                    if ADV.ENABLE_BEST_GUESS and tot > 0 then
                        local prob = m / tot
                        if not bestGuess or prob < bestGuess.p then
                            bestGuess = { part = p, p = prob }
                        end
                    end
                end
            end
        end
    end

    return {
        safeSet = safeSet,
        mineSet = mineSet,
        bestGuess = bestGuess,
        stats = {
            groups = #groups,
            vars = totalVars,
            solvedGroups = solvedGroups,
            solutions = sumSolutions,
        },
    }
end
-- === End Advanced Solver ===

-- SOLVER
local function analyze()
    local safe, mines, wrongFlags = {}, {}, {}
    local numberTiles = {}

    -- gather number tiles
    for k, part in pairs(gridMap) do
        if isNumberTile(part) then
            local num = readNumberFromPart(part)
            if num then
                table.insert(numberTiles, { part = part, number = num })
            end
        end
    end

    -- compute neighbors
    for _, t in ipairs(numberTiles) do
        local key = partToKey[t.part]
        if not key then
            t.flagged = 0
            t.unknown = {}
            t.unknownSet = {}
        else
            local tx, tz = key:match('([^|]+)|([^|]+)')
            tx, tz = tonumber(tx), tonumber(tz)
            t.flagged = 0
            t.unknown = {}
            t.unknownSet = {}
            for dx = -1, 1 do
                for dz = -1, 1 do
                    if not (dx == 0 and dz == 0) then
                        local n = gridMap[keyFromXZ(tx + dx, tz + dz)]
                        if n then
                            if isFlaggedTile(n) then
                                t.flagged = t.flagged + 1
                            elseif isUnrevealedTile(n) then
                                table.insert(t.unknown, n)
                                t.unknownSet[n] = true
                            end
                        end
                    end
                end
            end
        end
    end

    -- basic rules
    for _, t in ipairs(numberTiles) do
        local need = t.number - t.flagged
        if need == 0 then
            for _, n in ipairs(t.unknown) do
                safe[n] = true
            end
        elseif need == #t.unknown then
            for _, n in ipairs(t.unknown) do
                mines[n] = true
            end
        end
    end

    -- subset rules (A subset of B)
    for i = 1, #numberTiles do
        local A = numberTiles[i]
        for j = 1, #numberTiles do
            if i ~= j then
                local B = numberTiles[j]
                local isSubset = true
                -- empty unknownSet handling
                if not next(A.unknownSet) then
                    isSubset = false
                end
                for n in pairs(A.unknownSet) do
                    if not B.unknownSet[n] then
                        isSubset = false
                        break
                    end
                end
                if isSubset then
                    local needA = A.number - A.flagged
                    local needB = B.number - B.flagged
                    local diff = {}
                    for n in pairs(B.unknownSet) do
                        if not A.unknownSet[n] then
                            table.insert(diff, n)
                        end
                    end
                    if (needB - needA) == #diff then
                        for _, n in ipairs(diff) do
                            mines[n] = true
                        end
                    elseif needA == needB then
                        for _, n in ipairs(diff) do
                            safe[n] = true
                        end
                    end
                end
            end
        end
    end

    -- constraint solver (backtracking on frontier)
    local frontier, constraints, seen = {}, {}, {}
    for _, t in ipairs(numberTiles) do
        if #t.unknown > 0 then
            table.insert(
                constraints,
                { unknown = t.unknown, need = t.number - t.flagged }
            )
            for _, n in ipairs(t.unknown) do
                if not seen[n] then
                    seen[n] = true
                    table.insert(frontier, n)
                end
            end
        end
    end

    if #frontier > 0 and #frontier <= 20 then
        local vars = frontier
        local solutions = 0
        local mineCount, safeCount = {}, {}
        for _, n in ipairs(vars) do
            mineCount[n] = 0
            safeCount[n] = 0
        end

        local assign = {}
        local function backtrack(i)
            if i > #vars then
                -- verify all constraints
                for _, c in ipairs(constraints) do
                    local cnt = 0
                    for _, n in ipairs(c.unknown) do
                        if assign[n] then
                            cnt = cnt + 1
                        end
                    end
                    if cnt ~= c.need then
                        return
                    end
                end
                -- valid solution
                solutions = solutions + 1
                for _, n in ipairs(vars) do
                    if assign[n] then
                        mineCount[n] = mineCount[n] + 1
                    else
                        safeCount[n] = safeCount[n] + 1
                    end
                end
                return
            end
            assign[vars[i]] = true
            backtrack(i + 1)
            assign[vars[i]] = false
            backtrack(i + 1)
            assign[vars[i]] = nil
        end
        backtrack(1)

        if solutions > 0 then
            for _, n in ipairs(vars) do
                if mineCount[n] == solutions then
                    mines[n] = true
                elseif safeCount[n] == solutions then
                    safe[n] = true
                end
            end
        end
        dprint('Constraint solver: vars=', #vars, 'solutions=', solutions)
    end

    -- identify wrong flags (flagged but deduced safe)
    for p, _ in pairs(safe) do
        if isFlaggedTile(p) then
            wrongFlags[p] = true
            safe[p] = nil -- don't mark as blue if it's flagged incorrectly; show purple
        end
    end

    -- === Advanced layer when basics + small frontier backtracking fail ===
    local noCertainYet = (next(safe) == nil) and (next(mines) == nil)

    if noCertainYet then
        -- Build a compact numberTiles table compatible with AdvancedSolve
        local compact = {}
        for _, t in ipairs(numberTiles) do
            if #t.unknown > 0 then
                table.insert(compact, {
                    part = t.part,
                    number = t.number,
                    flagged = t.flagged,
                    unknown = t.unknown,
                })
            end
        end

        local adv = AdvancedSolve(compact) -- uses tight time budget internally

        -- Merge certainties
        for p, _ in pairs(adv.safeSet) do
            if not isFlaggedTile(p) then
                safe[p] = true
            else
                -- flagged but solver says safe => wrong flag
                wrongFlags[p] = true
            end
        end
        for p, _ in pairs(adv.mineSet) do
            mines[p] = true
        end

        -- Expose best guess to the outer loop via upvalue (or return value).
        _G.MSGuideBestGuess = adv.bestGuess -- {part=..., p=...} or nil

        if DEBUG and adv.bestGuess then
            dprint(string.format('BestGuess p=%.3f', adv.bestGuess.p))
        end
    else
        _G.MSGuideBestGuess = nil
    end

    return safe, mines, wrongFlags, #numberTiles
end

-- MAIN LOOP
rebuildMap()

-- ensure periodic full rebuild in case board mutates in-situ
spawn(function()
    while true do
        waitFn(2.5)
        rebuildMap()
    end
end)

spawn(function()
    while true do
        waitFn(SCAN_INTERVAL)
        if _G.MSGuideEnabled then
            local safe, mines, wrongFlags, numCount = analyze()

            local desired = {}

            -- apply highlights
            for p in pairs(safe) do
                if isFlaggedTile(p) then
                    -- flagged but deduced safe = wrong flag
                    desired[p] = true
                    setHighlight(p, Color3.fromRGB(170, 70, 200)) -- purple for wrong flag
                else
                    desired[p] = true
                    setHighlight(p, Color3.fromRGB(50, 150, 255)) -- blue = safe
                end
            end

            for p in pairs(mines) do
                if isFlaggedTile(p) then
                    -- correctly flagged mine â†’ no extra highlight needed
                    desired[p] = true
                    setHighlight(p, Color3.fromRGB(200, 90, 90)) -- faint red to confirm flag is correct
                else
                    desired[p] = true
                    setHighlight(p, Color3.fromRGB(200, 50, 50)) -- bright red = unflagged mine
                end
            end

            for p in pairs(wrongFlags) do
                desired[p] = true
                setHighlight(p, Color3.fromRGB(170, 70, 200)) -- purple for wrong flag
            end

            -- If we still have nothing actionable, show best guess (yellow)
            if not next(safe) and not next(mines) then
                local g = rawget(_G, 'MSGuideBestGuess')
                if g and g.part and g.part:IsDescendantOf(Workspace) then
                    setHighlight(g.part, Color3.fromRGB(245, 210, 70)) -- yellow = lowest-risk guess
                end
            end

            -- Also mark flagged tiles that solver hasn't colored: keep flagged but unknown as subtly outlined
            for _, child in
                ipairs(partsFolder and partsFolder:GetChildren() or {})
            do
                if
                    child:IsA('BasePart')
                    and isFlaggedTile(child)
                    and not desired[child]
                then
                    -- flagged but undetermined: keep a faint red highlight so user knows it's flagged
                    desired[child] = true
                    setHighlight(child, Color3.fromRGB(200, 90, 90))
                end
            end

            -- release highlights that are no longer desired
            for p, h in pairs(highlights) do
                if not desired[p] then
                    releaseHighlight(h)
                    highlights[p] = nil
                end
            end

            if infoLabel then
                local safeCount, mineCount, wrongCount = 0, 0, 0
                for _ in pairs(safe) do
                    safeCount = safeCount + 1
                end
                for _ in pairs(mines) do
                    mineCount = mineCount + 1
                end
                for _ in pairs(wrongFlags) do
                    wrongCount = wrongCount + 1
                end
                infoLabel.Text = string.format(
                    'Numbers: %d\nSafe: %d  Mines: %d  WrongFlags: %d',
                    numCount,
                    safeCount,
                    mineCount,
                    wrongCount
                )
            end
        else
            clearAllHighlights()
            if infoLabel then
                infoLabel.Text = 'Disabled'
            end
        end
    end
end)

-- TOGGLE
UserInput.InputBegan:Connect(function(inp, gp)
    if gp then
        return
    end
    if inp.KeyCode == Enum.KeyCode.Minus then
        _G.MSGuideEnabled = not _G.MSGuideEnabled
        dprint('Guide toggled:', _G.MSGuideEnabled)
        if not _G.MSGuideEnabled then
            clearAllHighlights()
        end
    end
end)
